---
title: "Analyzing dyadic data using linear mixed-effects models"
author: "Ginette Lafit (ginette.lafit@kuleuven.be)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
#  github_document:
#    toc: true
#    toc_depth: 2
#    number_sections: true
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
#    self_contained: false
    number_sections: true
bibliography: bibliography.bib 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preliminaries

## Preliminaries - Installing libraries used in this script (whenever is necessary).

```{r, echo=TRUE, warning=TRUE, results="hide", message=FALSE}
# This code chunk simply makes sure that all the 
# libraries used here are installed.
packages <- c("nlme", "tidyverse", "foreign", "data.table", "ggeffects", "psych", "sjPlot", "sjmisc", "sjlabelled")
if ( length(missing_pkgs <- setdiff(packages, 
  rownames(installed.packages()))) > 0) {
  message("Installing missing package(s): ", 
          paste(missing_pkgs, collapse = ", "))
  install.packages(missing_pkgs)
}
```

## Preliminaries - Loading libraries used in this script.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
library(nlme) # to estimate linear-mixed effect models
library(tidyverse) # reshaped data and variable transformation
library(foreign) # load .sav data set
library(data.table) # to create lagged outcome
library(ggeffects) # to create plots for the estimated effects
library(psych) # to compute descriptive statistics & some psychometrics
library(sjPlot) # to create html tables
library(sjmisc) # to create html tables
library(sjlabelled) # to create html tables
set.seed(1235) # Set a seed to reproduce analyses

# Get the session info (also for reproducibility)
sessionInfo()
```

# Data preprocessing for single intensive longitudinal analyses

We use the data from The Dyadic Interaction Study used in @sels2019all. The Dyadic Interaction Study includes 101 couples that self-identified as heterosexual which were in a relationship for at least 2 months and of which both partners were over the age of 18. Participants were recruited in the context of a larger study on emotion dynamics in intimate relationships, from which only the ESM part is relevant to this study. Participants were on average 26 years old (SD = 5 years, Min = 18, Max = 53), and had been in a relationship for 4.5 years (SD = 2.8, min = 7 months, max = 21 years). The majority of these couples were living together (n = 96) and did not have children yet (n = 5). The nationality of most participants was Belgian (n = 187). The other participants had a Dutch (n = 9), German (n = 3), Armenian (n = 1), Chinese (n = 1), or Ukrainian nationality (n = 1). Among half of the participants (n = 102) had a University degree, one-fourth had completed higher education (n = 43), and the remainder had a primary school (n = 1) or secondary school education level (n = 56). Participants were recruited through social media platforms, and flyers and posters that were distributed in public places in Leuven, Belgium. The study was approved by the ethics committee of the Faculty of Psychology and Educational Sciences of the KU Leuven. 

During the ESM period of 7 days, each partner reported on their feelings and other experiences several times a day. Specifically, partners reported whether they were together at a given moment (resulting in a dyad level Presence of the Partner variable when one of the partners said yes), how happy they were, and how much they had tried to make their partner feel understood and appreciated (i.e., enacted responsiveness). While the first item was dichotomous (0 = no, 1 = yes), the other items were answered by a sliding scale ranging from ‘not at all’ (0) to ‘very much’ (100). Both partners were considered together when one of the partners said so. Partners were prompted simultaneously, but the items were ordered randomly to avoid cooperation. During weekdays, partners were prompted 6 times a day, from 5 PM until 10 PM. On weekend days, partners were assessed 14 times a day, from 10 AM until 10 PM. These time spans were selected because partners were more likely to be together during these hours. Each time span was divided into equal intervals, and each signal was programmed randomly in each interval. Participants received a minimum of 47 and a maximum of 72 beeps. Participants for which data were missing due to practical and technical issues were excluded. The final sample includes 94 heterosexual couples. 

We first load the data set including the baseline questionnaire. 

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Load in background (or baseline) questionnaires
data.baseline = read.csv("background.csv", header = TRUE, sep = ';', dec = ".", stringsAsFactors = FALSE)

# Re-name dyad identification number
names(data.baseline)[names(data.baseline) == "ï..couple"] = "couple"

# Create variable Couple Satisfaction
data.baseline$couple_satisf = rowMeans(data.baseline[,c("PRQCI_satisfaction1","PRQCI_satisfaction2","PRQCI_satisfaction3" )], na.rm = TRUE)

# Change the level of the variable sex (F = vrouw, M = man)
data.baseline$sex = ifelse(data.baseline$sex == "vrouw", "F", "M")

# Find the dimensions
dim(data.baseline)

# Find the structure
str(data.baseline)

# See the first 6 rows
head(data.baseline)

# See the last 6 rows
tail(data.baseline)

# Find the column names
names(data.baseline)

# View the data set
View(data.baseline)
```

Subsequently, we load the ESM data set. 

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Load ESM person period data set
data.person = read.spss("ESM_8.sav", to.data.frame=TRUE)
data.person = data.frame(data.person)

# Find the dimensions
dim(data.person)

# Find the structure
str(data.person)

# See the first 6 rows
head(data.person)

# See the last 6 rows
tail(data.person)

# Find the column names
names(data.person)

# View the data set
View(data.person)

# Select variable to use 
data.person = data.person[,c("couple","ppnr","beepnr","DayESM","launchTime","happy","relaxed","enact_respons","together_0","together_1")]

# View a few rows of the data 
head(data.person)

# Add variable number of observation per person
data.person$obs = rep(0,nrow(data.person))
for (i in unique(data.person$ppnr)){
data.person$obs[which(data.person$ppnr==i)] = 1:length(which(data.person$ppnr==i))    
}

# Create presence of partner variable 
data.person$together = rowSums(cbind(1-data.person$together_0,data.person$together_1), na.rm=TRUE)

data.person$together = ifelse(is.na(data.person$together_0) & is.na(data.person$together_1),NA,data.person$together)

data.person = data.person[,c("couple","ppnr","beepnr","DayESM","launchTime","obs","happy","relaxed","enact_respons","together")]

# create variable Gender
data.person$gender = ifelse(data.person$ppnr == data.person$couple,"F","M")

```

The baseline data set includes more participants than the ESM data set. Thus, for the participants included in the ESM data set, we append the person-level or time-invariant variables *Age* and *couple satisfaction*.   

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Get the identification number of each participant
ID.dyad = unique(data.person$ppnr)

# Add variables Age and items related to couple satisfaction to the ESM data set
data.person$age = rep(0,nrow(data.person))
data.person$couple_satisf = rep(0,nrow(data.person))
for (i in ID.dyad){
ID.couple.i = unique(data.person$couple[which(data.person$ppnr==i)])  
Gender.i = unique(data.person$gender[which(data.person$ppnr==i)])    
data.person$age[which(data.person$ppnr==i)] = data.baseline$age[which(c(data.baseline$couple==ID.couple.i & 
                                                                      data.baseline$sex==Gender.i) == TRUE)]
data.person$couple_satisf[which(data.person$ppnr==i)] = data.baseline$couple_satisf[which(c(data.baseline$couple==ID.couple.i & 
                                                                      data.baseline$sex==Gender.i) == TRUE)]
}

# Find the structure
str(data.person)

# summary of the data
summary(data.person)

# See the first 6 rows
head(data.person)

# See the last 6 rows
tail(data.person)

# Order the variables 
data.person = data.person[,c("couple","ppnr","beepnr","DayESM","launchTime","obs","gender","age","couple_satisf","happy","relaxed","enact_respons","together")]

```

# Visulations and descriptive statistics

We first obtain some descriptive statistics including number of dyads, number of participant, number of observations per day, and compliance. 

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Get number of dyads
length(unique(data.person$couple)) 

# Get number of participants
length(unique(data.person$ppnr))

# Get the number of assessment per day
table(data.person$DayESM)
# Get the number of assessment per day for each participant
beeps.person = lapply(data.person$ppnr, function(i) table(data.person$DayESM[which(data.person$ppnr==i)]))
# Show results for some of the participants
beeps.person[1:6]

# Distribution of the launch time per participant
data.table.dt = setDT(data.person)
data.table.dt[, as.list(summary(launchTime)), by = ppnr]

# Plot the distribution of launch time per participant (we sample 10 participants)
n.ID.sample = sample(unique(data.person$ppnr),10)
data.person.sample = data.person[which(data.person$ppnr %in% n.ID.sample),]
ggplot(data.person.sample, aes(x=obs, launchTime)) + geom_point() + facet_wrap(~ppnr)


# Compute a binary variable indicating if a participant answered a beep. We take the ESM item Happy as reference
data.person$Compliance = ifelse(is.na(data.person$happy)==FALSE, 1, 0)

# Mean, median of the compliance across all participants
describe(data.person$Compliance)

# Compliance per participant
data.compliance.person = aggregate(data.person$Compliance, by = list(data.person$ppnr), mean, na.rm = TRUE)

# See the first 6 rows
head(data.compliance.person)
     
# See the last 6 rows
tail(data.compliance.person)

# Obtain descriptive statistics of person's average compliance 
describe(data.compliance.person$x)

```

Next, we obtain visualizations and statistics of the distribution of the person-level or time-invariant variables variables

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# We create a variable including the Gender (1 = F, 2 = M), Age and Couple Satisfaction of each participant
dt.person = aggregate(cbind(as.numeric(as.factor(data.person$gender)),data.person$happy), by = list(data.person$ppnr), mean, na.rm = TRUE)
colnames(dt.person) = c("Group.1","gender","happy")

# See the first 6 rows
head(dt.person)
     
# See the last 6 rows
tail(dt.person)

# Descriptive statistics for person's means of time-varying variable happy
describe(dt.person$happy)

# Descriptive statistics for person's means of time-varying variable happy for women
describe(dt.person$happy[dt.person$gender==1])

# Descriptive statistics for person's means of time-varying variable happy for men
describe(dt.person$happy[dt.person$gender==2])


```

We now focus on time-varying variables, we obtain visualization and descriptive statistics

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Histogram for the time-varying variable happy
ggplot(data.person, aes(happy)) + geom_histogram(color="black", fill="white",bins=30) 

# Histogram for the time-varying variable happy by gender
ggplot(data.person, aes(happy)) + geom_histogram(color="black", fill="white",bins=30) +
  facet_wrap(~gender)

# Descriptive statistics for happy
describe(data.person$happy)

# Descriptive statistics for happy for women
describe(data.person$happy[data.person$gender=='F'])

# Descriptive statistics for happy for men
describe(data.person$happy[data.person$gender=='M'])

# Distribution of happy per participant
data.table.dt = setDT(na.omit(data.person))
data.table.dt[, as.list(summary(happy, na.omit = TRUE)), by = ppnr]

# We randomly select 10 participants for plotting the distribution of the time-varying variable happy 
n.ID.sample = sample(unique(data.person$ppnr),10)
data.person.sample = data.person[which(data.person$ppnr %in% n.ID.sample),]

# Histogram for the time-varying variable happy by person
ggplot(data.person.sample, aes(happy)) + geom_histogram(color="black", fill="white",bins=30) +
  facet_wrap(~ppnr)

# Plot the trajectories of the time-varying variable happy by person
data.person.sample %>% 
  ggplot(aes(x = obs, y = happy)) + 
  geom_point() + 
  geom_line() +  # add lines to connect the data for each person 
  facet_wrap( ~ ppnr)

# We create a variable including the Gender (1 = F, 2 = M), and person's means of the time-varying variable happy
dt.person = aggregate(cbind(as.numeric(as.factor(data.person$gender)),data.person$happy), by = list(data.person$ppnr), mean, na.rm = TRUE)
colnames(dt.person) = c("Group.1","gender","happy")

# See the first 6 rows
head(dt.person)
     
# See the last 6 rows
tail(dt.person)

# Descriptive statistics for person's means of the time-varying variable happy
describe(dt.person$happy)

# Descriptive statistics for person's means of the time-varying variable happy for women
describe(dt.person$happy[dt.person$gender==1])

# Descriptive statistics for person's means of the time-varying variable happy for men
describe(dt.person$happy[dt.person$gender==2])

# We create a variable including the Gender (1 = F, 2 = M), and person's standard deviation of the time-varying variable happy
dt.person = aggregate(data.person$happy, by = list(data.person$ppnr), sd, na.rm = TRUE)
colnames(dt.person) = c("Group.1","happy")

# See the first 6 rows
head(dt.person)
     
# See the last 6 rows
tail(dt.person)

# Descriptive statistics for person's standard deviation of the time-varying variable happy
describe(dt.person$happy)

# Visualization of the trajectories for the members of a dyad
## We first randomly select a dyad  
dyad.ID.sample = sample(unique(data.person$couple),1)
data.dyad.sample = data.person[which(data.person$couple==dyad.ID.sample),]
# Add variable number of observation per person
data.dyad.sample$obs = rep(0,nrow(data.dyad.sample))
for (i in unique(data.dyad.sample$ppnr)){
data.dyad.sample$obs[which(data.dyad.sample$ppnr==i)] = 1:length(which(data.dyad.sample$ppnr==i))    
}

# Plot the trajectories of the time-varying variable happy by person
data.dyad.sample %>% 
  ggplot(aes(x = obs, y = happy)) + 
  geom_point() + 
  geom_line() +  # add lines to connect the data for each person 
  facet_wrap( ~ ppnr)

```

# Data preprocessing for dyadic intensive longitudinal analyses

The ESM data set is in a long format. To estimate APIMs models and VAR(1)-based models taking into account the dyadic structure using linear mixed-effects models, we need to re-structure the data set (see e.g., @laurenceau2012analyzing). 

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# create variable Gender
data.person$Gender = ifelse(data.person$ppnr == data.person$couple,'F','M')

# Create lag outcome (happy): for each person lagged within days
data.person$happy.lag = rep(0,nrow(data.person))
n.subject = unique(data.person$ppnr)
for (j in n.subject){
n.day.j = unique(data.person$DayESM)
for (t in n.day.j){  
data.person$happy.lag[which(data.person$ppnr==j & data.person$DayESM==t)] = shift(data.person$happy[which(data.person$ppnr==j & data.person$DayESM==t)])
}}

# Re-shape the data into dyadic data set
data.dyad = data.person[,c('couple','ppnr','beepnr','DayESM','Gender','age','couple_satisf')]

# Re-name the variables 
colnames(data.dyad) = c('dyad.ID','subject.ID','Obs','Day','Gender','Age','couple_satisf')

# Create variable Female and Male
data.dyad$Female = ifelse(data.dyad$Gender == 'F',1,0)
data.dyad$Male = ifelse(data.dyad$Gender == 'M',1,0)

# Re-shape data set: Y (happy), X (enact_response)
data.dyad$Y.happy = rep(0,nrow(data.dyad))
data.dyad$Y.happy.lag = rep(0,nrow(data.dyad))
data.dyad$Y.Actor.lag = rep(0,nrow(data.dyad))
data.dyad$Y.Partner.lag = rep(0,nrow(data.dyad))
data.dyad$X.Actor = rep(0,nrow(data.dyad))
data.dyad$X.Partner = rep(0,nrow(data.dyad))
data.dyad$D.Actor = rep(0,nrow(data.dyad))
data.dyad$D.Partner = rep(0,nrow(data.dyad))

N.dyad = unique(data.dyad$dyad.ID)
for (i in N.dyad){
N.id = which(data.dyad$dyad.ID==i)

data.dyad$Y.happy[N.id[which(data.person[N.id,]$Gender=='F')]] = data.person$happy[N.id[which(data.person[N.id,]$Gender=='F')]]

data.dyad$Y.happy[N.id[which(data.dyad[N.id,]$Gender=='M')]] = data.person$happy[N.id[which(data.person[N.id,]$Gender=='M')]]

data.dyad$Y.happy.lag[N.id[which(data.person[N.id,]$Gender=='F')]] = data.person$happy.lag[N.id[which(data.person[N.id,]$Gender=='F')]]

data.dyad$Y.happy.lag[N.id[which(data.dyad[N.id,]$Gender=='M')]] = data.person$happy.lag[N.id[which(data.person[N.id,]$Gender=='M')]]

data.dyad$X.Actor[N.id[which(data.dyad[N.id,]$Gender=='F')]] = data.person$enact_respons[N.id[which(data.person[N.id,]$Gender=='F')]] 

data.dyad$X.Actor[N.id[which(data.dyad[N.id,]$Gender=='M')]] = data.person$enact_respons[N.id[which(data.person[N.id,]$Gender=='M')]] 

data.dyad$X.Partner[N.id[which(data.dyad[N.id,]$Gender=='F')]] = data.person$enact_respons[N.id[which(data.person[N.id,]$Gender=='M')]]

data.dyad$X.Partner[N.id[which(data.dyad[N.id,]$Gender=='M')]] = data.person$enact_respons[N.id[which(data.person[N.id,]$Gender=='F')]]

data.dyad$Y.Actor.lag[N.id[which(data.dyad[N.id,]$Gender=='F')]] = data.person$happy.lag[N.id[which(data.person[N.id,]$Gender=='F')]] 

data.dyad$Y.Actor.lag[N.id[which(data.dyad[N.id,]$Gender=='M')]] = data.person$happy.lag[N.id[which(data.person[N.id,]$Gender=='M')]] 

data.dyad$Y.Partner.lag[N.id[which(data.dyad[N.id,]$Gender=='F')]] = data.person$happy.lag[N.id[which(data.person[N.id,]$Gender=='M')]]

data.dyad$Y.Partner.lag[N.id[which(data.dyad[N.id,]$Gender=='M')]] = data.person$happy.lag[N.id[which(data.person[N.id,]$Gender=='F')]]

data.dyad$D.Actor[N.id[which(data.dyad[N.id,]$Gender=='F')]] = data.person$together[N.id[which(data.person[N.id,]$Gender=='F')]] 

data.dyad$D.Actor[N.id[which(data.dyad[N.id,]$Gender=='M')]] = data.person$together[N.id[which(data.person[N.id,]$Gender=='M')]] 

data.dyad$D.Partner[N.id[which(data.dyad[N.id,]$Gender=='F')]] = data.person$together[N.id[which(data.person[N.id,]$Gender=='M')]]

data.dyad$D.Partner[N.id[which(data.dyad[N.id,]$Gender=='M')]] = data.person$together[N.id[which(data.person[N.id,]$Gender=='F')]]
}

# Create variable dyad variable together
data.dyad$D = data.dyad$D.Actor + data.dyad$D.Partner

# Number of beeps where the both partners said they were together
length(which(data.dyad$D==2))

# Proportion of beeps where the both partners said they were together
length(which(data.dyad$D==2))/length(data.dyad$D.Partner)

# Number of beeps where the both partners said they were not together
length(which(data.dyad$D==0))

# Proportion of beeps where the both partners said they were not together
length(which(data.dyad$D==0))/length(data.dyad$D.Partner)

# Number of beeps where the both partners said they were disagree of being together
length(which(data.dyad$D==1))

# Proportion of beeps where the both partners said they were disagree of being together
length(which(data.dyad$D==1))/length(data.dyad$D.Partner)

# Select beeps where at least one of the dyad members said that they were together
data.dyad$D = ifelse(data.dyad$D==2, 1, data.dyad$D)

# Number of beeps where the both partners said they were at least one of the partners were together
length(which(data.dyad$D==1))

# Proportion of beeps where the both partners said they were at least one of the partners were together
length(which(data.dyad$D==1))/length(data.dyad$D.Partner)

```

# Create person-mean centered time-varying predictors

Next, we are going to create variable with person-mean centered predictors:

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Person-mean centered the predictors and create a variable with person's mean
data.dyad <- data.dyad %>% 
group_by(subject.ID,dyad.ID) %>% 
mutate(X.Actor.c = X.Actor - mean(X.Actor,na.rm = TRUE),
       X.Partner.c = X.Partner - mean(X.Partner,na.rm = TRUE),
       X.Actor.mean = mean(X.Actor,na.rm = TRUE),
       X.Partner.mean = mean(X.Partner,na.rm = TRUE))

# See the first 6 rows
head(data.dyad)
     
# See the last 6 rows
tail(data.dyad)

```

# Estimate linear models for average of person-level data (cross-sectional data)

We first illustrate how to estimate a linear model for cross-sectional data. Thus, we are going to compute the persons' means of the variables included in the data set *data.dyad*.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# First, we re-code the variable Gender from a categorical to numerical variable
# in the new data set 'data.dyad.num' Gender =  0 for female partner and Gender = 1 for male partner
data.dyad.num = data.dyad
data.dyad.num$Gender = as.numeric(as.factor(data.dyad.num$Gender))-1

# Create a data set by computing the person's mean.
data.dyad.mean = aggregate(data.dyad.num, by = list(data.person$ppnr), mean, na.rm = TRUE)
```

## Estimate linear model for male partners

We estimate a linear model to investigate the effect of persons' mean enacted response on the person's happiness for male partners using a linear model estimates by least squares.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Estimate the linear model
fit.Model.1 = lm(Y.happy ~ 1 + X.Actor,
                  data = data.dyad.mean[which(data.dyad.mean$Gender==1),]) 

summary(fit.Model.1)
tab_model(fit.Model.1)

# Plot predictions for the person-mean enacted response for male partners
ggpredict(fit.Model.1, terms = c("X.Actor")) |> plot()
 
```

## Estimate linear model for male partners with moderation effects

We estimate a linear model to investigate if the effect of persons' mean enacted response on the person's happiness for male partners is moderated by the averate time in which participants are together during the ESM period. We use a linear model estimated by least squares.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Estimate the linear model
fit.Model.2 = lm(Y.happy ~ 1 + X.Actor + X.Actor*D,
                  data = data.dyad.mean[which(data.dyad.mean$Gender==1),]) 

summary(fit.Model.2)
tab_model(fit.Model.2)

# Plot predictions for the person-mean enacted response for male partners
ggpredict(fit.Model.2, terms = c("X.Actor", "D")) |> plot()
 
```

## Estimate APIM for distinguishable partners

We estimate a linear model to investigate the actor and partner effect of persons' mean enacted response on the person's happiness for dyadic partners using a generalized linear models.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Estimate APIM model for distinguishable partners

fit.Model.3 = gls(Y.happy ~ -1 + Female + Female:X.Actor + Female:X.Partner  + 
                  Male + Male:X.Actor + Male:X.Partner,
               correlation = corSymm(form= ~1|dyad.ID),
               weights = varIdent(form= ~1|Gender),    
               data = data.dyad.mean,
               na.action = na.exclude)

summary(fit.Model.3)

```

## Estimate APIM for indistinguishable partners

We estimate a linear model to investigate the actor and partner effect of persons' mean enacted response on the person's happiness for dyadic partners for dyadic partners using a generalized linear models.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Estimate APIM model for indistinguishable partners

fit.Model.4 = gls(Y.happy ~ 1 + X.Actor + X.Partner,
               correlation = corSymm(form= ~1|dyad.ID),
               weights = varIdent(form= ~1|Gender),    
               data = data.dyad.mean,
               na.action = na.exclude)

summary(fit.Model.4)

```

## Estimate APIM for distinguishable partners with moderation effects

We estimate a linear model to investigate if the actor and partner effect of persons' mean enacted response on the person's happiness is moderated by the average number of beeps that dyadic partners spend together.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Create the interaction variable between enacted response and the average number of beeps that dyadic partners spend together
data.dyad.mean$D.X.Actor = data.dyad.mean$D*data.dyad.mean$X.Actor
data.dyad.mean$D.X.Partner = data.dyad.mean$D*data.dyad.mean$X.Partner

# Estimate APIM model for distinguishable partners with moderation effects

fit.Model.5 = gls(Y.happy ~ -1 + Female + Female:X.Actor + Female:X.Partner  + 
                  + Female:D + Female:D.X.Actor + Female:D.X.Partner +  
                  Male + Male:X.Actor + Male:X.Partner + 
                  Male:D + Male:D.X.Actor + Male:D.X.Partner,
               correlation = corSymm(form= ~1|dyad.ID),
               weights = varIdent(form= ~1|Gender),    
               data = data.dyad.mean,
               na.action = na.exclude)

summary(fit.Model.5)

```

## Estimate APIM for indistinguishable partners with moderation effects

We estimate a linear model to investigate if the actor and partner effect of persons' mean enacted response on the person's happiness is moderated by the average number of beeps that dyadic partners spend together.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Estimate APIM model for indistinguishable partners  with moderation effects

fit.Model.6 = gls(Y.happy ~ 1 + X.Actor + X.Partner +
                  D + D.X.Actor + D.X.Partner,
               correlation = corSymm(form= ~1|dyad.ID),
               weights = varIdent(form= ~1|Gender),    
               data = data.dyad.mean,
               na.action = na.exclude)

summary(fit.Model.6)

```

# Estimate linear models for a single person (time series data)

We estimate a model for a single person. As an illustration, we select the data for women participants and we investigate if enacted response predicts happy.

## Linear model to estimate the effect of enacted response on happy 

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Estimate the model assuming errors are independent

fit.Model.7.A = lm(Y.happy ~ 1 + X.Actor,
                  data = data.dyad[which(data.dyad$subject.ID==6),]) 

summary(fit.Model.7.A)
tab_model(fit.Model.7.A)

# Plot predictions for the person-mean centered enacted response for 5 persons
ggpredict(fit.Model.7.A, terms = c("X.Actor")) |> plot()
 
# Estimate the model assuming errors follow AR(1) process
fit.Model.7.B = gls(Y.happy ~ 1 + X.Actor, correlation = corAR1(form=~1), 
                    data = data.dyad[which(data.dyad$subject.ID==6),], na.action=na.omit)

summary(fit.Model.7.B)

```

## Linear model to estimate the autoregressive effect of happiness

We estimate an AR(1) model for a single participant.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
fit.Model.8 = lm(Y.happy ~ 1 + Y.happy.lag,
                  data = data.dyad[which(data.dyad$subject.ID==6),]) 

summary(fit.Model.8)
tab_model(fit.Model.8)

# Plot predictions for the person-mean centered enacted response for 5 persons
ggpredict(fit.Model.8, terms = c("Y.happy.lag")) |> plot()


```

# Estimate linear mixed-effect models for single persons design

Firstly, we estimate a model for a single persons intensive longitudinal design. As an illustration, we select the data for women participants and we investigate if enacted response predicts happy.

## Linear mixed-effects model to estimate the effect of enacted response on happy assuming Level 1 errors are independent 

We consider the women, and we estimate a linear mixed-effects model assuming the Level 1 errors are independent.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
fit.Model.9 = lme(fixed = Y.happy ~ 1 + X.Actor.c,
                  random = ~ 1 + X.Actor.c|subject.ID,
                  data = data.dyad[which(data.dyad$Gender=='M'),], na.action=na.omit, 
                  control=list(msVerbose=FALSE, maxIter=500, msMaxIter=500)) 

summary(fit.Model.9)
tab_model(fit.Model.9)

# Plot predictions for the person-mean centered enacted response for 5 persons
ggpredict(fit.Model.9, terms = c("X.Actor.c", "subject.ID [811,810,804]"), type = "random") |> plot()


```

## Linear mixed-effects model to estimate the effect of enacted response on happy assuming Level 1 errors follow an Autorregressive (AR(1)) model 

We consider the women, and we estimate a linear mixed-effects model assuming the Level 1 errors follow and AR(1) process.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
fit.Model.10 = lme(fixed = Y.happy ~ 1 + X.Actor.c,
                  random = ~ 1 + X.Actor.c|subject.ID,
                  corr = corAR1(),
                  data = data.dyad[which(data.dyad$Gender=='M'),], na.action=na.omit, 
                  control=list(msVerbose=FALSE, maxIter=500, msMaxIter=500)) 

summary(fit.Model.10)
tab_model(fit.Model.10)

# Plot predictions for the person-mean centered enacted response for 5 persons
ggpredict(fit.Model.10, terms = c("X.Actor.c", "subject.ID [811,810,804]"), type = "random") |> plot()


```

## Linear mixed-effects model to estimate the effect of enacted response on happy assuming Level 1 errors are independent including moderation effects

We consider the women, and we estimate a linear mixed-effects model assuming the Level 1 errors are independent and including moderation effects of a time-varying dummy variable indicating whether partners where together in the moment of the assessment. 

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
fit.Model.11 = lme(fixed = Y.happy ~ 1 + X.Actor.c + D + X.Actor.c*D,
                  random = ~ 1 + X.Actor.c + D|subject.ID,
                  data = data.dyad[which(data.dyad$Gender=='M'),], na.action=na.omit, 
                  control=list(msVerbose=FALSE, maxIter=500, msMaxIter=500)) 

summary(fit.Model.11)
tab_model(fit.Model.11)

# Plot predictions for the person-mean centered enacted response for 5 persons
ggpredict(fit.Model.10, terms = c("X.Actor.c", "subject.ID [811,810,804]"), type = "random") |> plot()

```

## Linear mixed-effects model to estimate the autoregressive effect of happiness

Next, we estimate a multilevel AR(1) model using a linear mixed-effects model for women.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
fit.Model.12 = lme(fixed = Y.happy ~ 1 + Y.happy.lag,
                  random = ~ 1 + Y.happy.lag|subject.ID,
                  data = data.dyad[which(data.dyad$Gender=='M'),], na.action=na.omit, 
                  control=list(msVerbose=FALSE, maxIter=500, msMaxIter=500)) 

summary(fit.Model.12)
tab_model(fit.Model.12)

```

# Estimate longitudinal actor and partner interdependence model (L-APIM)

We estimate the longitudinal APIM using ESM data. 

## L-APIM for distinguishable partners

We estimate the L-APIM using linear mixed-effects models for distinguishable partners.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
fit.Model.13 = lme(fixed = Y.happy ~ -1 + Female + Female:X.Actor.c  + Female:X.Partner.c  + 
                  Male + Male:X.Actor.c + Male:X.Partner.c,
                  random = ~ -1 + Female + Male |dyad.ID, 
                  correlation = corCompSymm(form = ~1|dyad.ID/Obs),
                  weights = varIdent(form = ~1|Gender),
                  data = data.dyad, na.action=na.omit, 
                  control=list(msVerbose=FALSE, maxIter=500, msMaxIter=500)) 

summary(fit.Model.13)
tab_model(fit.Model.13)

```

## L-APIM for indistinguishable partners

We estimate the L-APIM using linear mixed-effects models for indistinguishable partners.

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
fit.Model.14 = lme(fixed = Y.happy ~ 1 + X.Actor.c + X.Partner.c,
                  random = list(dyad.ID = pdCompSymm(~ Gender -1)), 
                  correlation = corCompSymm(form = ~1|dyad.ID/Obs),
                  weights = varIdent(form = ~1|Gender),
                  data = data.dyad, na.action=na.omit, 
                  control=list(msVerbose=FALSE, maxIter=500, msMaxIter=500)) 

summary(fit.Model.14)
```

# Estimate L-APIM with moderation effects 

We estimate L-APIM including moderation effects of a dyad-level time-varying variable on the actor and partner effects.

##L-APIM for distinguishable dyads with moderation effects

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Create variables including interaction between predictor enacted response and the time-varying moderation time spend together
data.dyad$D.X.Actor.c = data.dyad$D* data.dyad$X.Actor.c
data.dyad$D.X.Partner.c = data.dyad$D* data.dyad$X.Partner.c

# Estimate L-APIM with moderation effects
fit.Model.15 = lme(fixed = Y.happy ~ -1 + Female + Female:X.Actor.c  + Female:X.Partner.c  + 
                  + Female:D + Female:D.X.Actor.c + Female:D.X.Actor.c +  
                  Male + Male:X.Actor.c + Male:X.Partner.c +
                  + Male:D + Male:D.X.Actor.c + Male:D.X.Actor.c,
                  random = ~ -1 + Female + Male |dyad.ID, 
                  correlation = corCompSymm(form = ~1|dyad.ID/Obs),
                  weights = varIdent(form = ~1|Gender),
                  data = data.dyad, na.action=na.omit, 
                  control=list(msVerbose=FALSE, maxIter=500, msMaxIter=500)) 

summary(fit.Model.15)
tab_model(fit.Model.15)

```

## L-APIM for indistinguishable dyads with moderation effects

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
fit.Model.16 = lme(fixed = Y.happy ~ 1 + X.Actor.c + X.Partner.c +
                  + D + D.X.Actor.c + D.X.Partner.c,
                  random = list(dyad.ID = pdCompSymm(~ Gender -1)), 
                  correlation = corCompSymm(form = ~1|dyad.ID/Obs),
                  weights = varIdent(form = ~1|Gender),
                  data = data.dyad, na.action=na.omit, 
                  control=list(msVerbose=FALSE, maxIter=500, msMaxIter=500)) 

summary(fit.Model.16)
```

# Estimate vector autoregressive model (VAR(1)) for dyadic partners

We estimate a VAR(1)-based models for the partners using linear mixed-effects models.

## VAR(1) for distinguishable dyads

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
fit.Model.17 = lme(fixed = Y.happy ~ -1 + Female + 
                  Female:Y.Actor.lag + Female:Y.Partner.lag + 
                  Male + Male:Y.Actor.lag + Male:Y.Partner.lag,
                  random = ~ -1 + Female + Male |dyad.ID, 
                  correlation = corCompSymm(form = ~1|dyad.ID/Obs),
                  weights = varIdent(form = ~1|Gender),
                  data = data.dyad, na.action=na.omit, 
                  control=list(msVerbose=FALSE, maxIter=500, msMaxIter=500)) 

summary(fit.Model.17)
tab_model(fit.Model.17)
```


## VAR(1) Model for indistinguishable dyads

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
fit.Model.18 = fit.Model.2 = lme(fixed = Y.happy ~ 1 + Y.Actor.lag + Y.Partner.lag,
                  random = list(dyad.ID = pdCompSymm(~ Gender -1)), 
                  correlation = corCompSymm(form = ~1|dyad.ID/Obs),
                  weights = varIdent(form = ~1|Gender),
                  data = data.dyad, na.action=na.omit, 
                  control=list(msVerbose=FALSE, maxIter=500, msMaxIter=500)) 

summary(fit.Model.18)
```

## VAR(1) for distinguishable dyads with moderation effects

This model incorporates interaction effects between the lagged predictors of the two partners and a time-varying predictor. The model allows estimating moderation effects in the auto- and cross-regressive effects. 

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
# Create variables including interaction between lagged predictor and the time-varying moderation time spend together
data.dyad$D.Y.Actor.lag = data.dyad$D*data.dyad$Y.Actor.lag
data.dyad$D.Y.Partner.lag = data.dyad$D*data.dyad$Y.Partner.lag

# Estimate VAR(1) model
fit.Model.19 = lme(fixed = Y.happy ~ -1 + Female + 
                  Female:Y.Actor.lag + Female:Y.Partner.lag + 
                  Female:D + Female:D.Y.Actor.lag + Female:D.Y.Partner.lag +
                  Male + Male:Y.Actor.lag + Male:Y.Partner.lag +
                  Male:D + Male:D.Y.Actor.lag + Male:D.Y.Partner.lag,
                  random = ~ -1 + Female + Male |dyad.ID, 
                  correlation = corCompSymm(form = ~1|dyad.ID/Obs),
                  weights = varIdent(form = ~1|Gender),
                  data = data.dyad, na.action=na.omit, 
                  control=list(msVerbose=FALSE, maxIter=500, msMaxIter=500)) 

summary(fit.Model.19)
tab_model(fit.Model.19)
```


## VAR(1) Model for indistinguishable dyads with moderation effects

```{r, echo=TRUE, warning=FALSE, eval=TRUE}
fit.Model.20 = fit.Model.2 = lme(fixed = Y.happy ~ 1 + Y.Actor.lag + Y.Partner.lag + 
                  D + D.Y.Actor.lag + D.Y.Partner.lag,
                  random = list(dyad.ID = pdCompSymm(~ Gender -1)), 
                  correlation = corCompSymm(form = ~1|dyad.ID/Obs),
                  weights = varIdent(form = ~1|Gender),
                  data = data.dyad, na.action=na.omit, 
                  control=list(msVerbose=FALSE, maxIter=500, msMaxIter=500)) 

summary(fit.Model.20)
```

# References
\addcontentsline{toc}{section}{References}

